<template>
  <div class="container">
    <text class="title">箱即是空</text>

    <!-- 游戏信息 -->
    <div class="info">
      <text class="infoText">
        控制:
        <text
          class="playerBadge"
          style="color: {{ currentPlayer === 6 ? '#333333' : '#FFFFFF' }};  
                     background-color: {{ currentPlayer === 6 ? '#FFFFFF' : '#333333' }};"
        >
          {{ currentPlayer === 6 ? "白" : "黑" }}
        </text>
      </text>
      <text class="hint">白走黑，黑走白</text>
    </div>

    <!-- 画布 -->
    <div class="gameArea">
      <div class="row" for="(y, indexY) in [0, 1, 2, 3, 4, 5, 6, 7]">
        <div class="cell" style="background-color: {{ getCellBg(y, x) }}; 
                    border-color: {{ getCellBorder(y, x) }}"
          for="(x, indexX) in [0, 1, 2, 3, 4]">
          <text class="icon" style="color: {{ getIconColor(y, x) }};">
            {{ getIcon(y, x) }}
          </text>
        </div>
      </div>
    </div>

    <!-- 控制区域 -->
    <div class="controlArea">
      <!-- 重置按钮 -->
      <div class="btnReset" style="background-color: {{ resetBtnColor }}" onclick="onReset">
        <text class="btnText">重置</text>
      </div>
      <!-- 切换角色按钮（input不支持background-color，改为div） -->
      <div class="switchArea">
        <div class="btnSwitch" id="switchBtn" style="background-color: {{ switchBtnColor }}" onclick="onSwitch">
          <text class="btnText">{{ currentPlayer === 6 ? "切换到黑" : "切换到白" }}</text>
        </div>
      </div>

      <!-- 方向键（input不支持background-color，改为div） -->
      <div class="controlPanel">
        <div class="btnRow1">
          <div class="btnArrow" style="background-color: {{ upBtnColor }}" onclick="onUp">
            <text class="btnText">↑</text>
          </div>
        </div>
        <div class="btnRow2">
          <div class="btnArrow" style="background-color: {{ leftBtnColor }}" onclick="onLeft">
            <text class="btnText">←</text>
          </div>
          <div class="btnArrow" style="background-color: {{ downBtnColor }}" onclick="onDown">
            <text class="btnText">↓</text>
          </div>
          <div class="btnArrow" style="background-color: {{ rightBtnColor }}" onclick="onRight">
            <text class="btnText">→</text>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
// 导入 prompt 模块
const prompt = require("@system.prompt")

export default {
  private: {
      // 疑似二维数组不触发UI更新，换一维键值对
      // 地图规则: 0=白地, 1=黑墙
      mapRules: {
      // key: "y,x", value: 0/1
      },
      whiteX: 0,
      whiteY: 1,
      blackX: 2,
      blackY: 3,
      currentPlayer: 7, // 黑
      moveCount: 0,
      // 按钮颜色
      switchBtnColor: "#3498DB",   // 蓝色：切换
      upBtnColor: "#2ECC71",       // 绿色：向上
      downBtnColor: "#2ECC71",
      leftBtnColor: "#2ECC71",
      rightBtnColor: "#2ECC71",
      resetBtnColor: "#E74C3C",    // 红色：重置

      // 箱子数据
      whiteBoxes: [],
      blackBoxes: [],
      // 目标点
      whiteTargets: [],
      blackTargets: [],
  },

  onInit() {
    this.initLevel()
  },
  
  initLevel() {
    this.initMapRules()
    this.initBoxes()
    this.initTargets()
  },
  initBoxes() {
    // 白箱子只能在黑色地形上移动
    this.whiteBoxes = [
        {x: 1, y: 2},
        {x: 2, y: 1}
    ];
    // 黑箱子只能在白色地形上移动
    this.blackBoxes = [
        {x: 1, y: 4}
    ];
},

initTargets() {
    // 白箱子目标点
    this.whiteTargets = [
        {x: 1, y: 5},
        {x: 2, y: 5}
    ];
    // 黑箱子目标点
    this.blackTargets = [
        {x: 2, y: 3}
    ];
},

  initMapRules() {
    const width = 5,
      height = 8
    this.mapRules = {}

    // 1. 所有位置默认白地（0）
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        this.mapRules[y + "," + x] = 0
      }
    }

    // 2. 四周黑墙(1)
    for (let x = 0; x < width; x++) {
      this.mapRules[0 + "," + x] = 1 //顶部
      this.mapRules[height - 1 + "," + x] = 1 //底部
    }

    for (let y = 0; y < height; y++) {
      this.mapRules[y + "," + 0] = 1 //左边
      this.mapRules[y + "," + (width - 1)] = 1 //右边
    }

    // 3. 内部黑墙
    this.mapRules["1,2"] = 1
    this.mapRules["2,2"] = 1

    // 4. 初始化角色位置
    this.whiteX = 0
    this.whiteY = 1
    this.blackX = 2
    this.blackY = 3
  },

  getMapValue(y, x) {
    return this.mapRules[y + "," + x] || 0
  },

  // 返回画布中单元格背景颜色
  getCellBg(y, x) {
    const isWhiteTarget = this.whiteTargets.some(t => t.x === x && t.y === y)
    const isBlackTarget = this.blackTargets.some(t => t.x === x && t.y === y)
    const hasWhiteBox = this.whiteBoxes.some(b => b.x === x && b.y === y)
    const hasBlackBox = this.blackBoxes.some(b => b.x === x && b.y === y)
    
    // 优先级: 角色 > 箱子 > 目标点 > 地图
    if (y === this.whiteY && x === this.whiteX) return "#FFFFFF"
    if (y === this.blackY && x === this.blackX) return "#000000"
    if (hasWhiteBox) return "#E0E0E0"
    if (hasBlackBox) return "#1A1A1A"
    if (isWhiteTarget) return "#FCD3D3"
    if (isBlackTarget) return "#333333"

    return this.getMapValue(y, x) === 0 ? "#F8F9FA" : "#2D3748"
  },

  // 返回画布中单元格边框颜色
  getCellBorder(y, x) {
    if (y === this.whiteY && x === this.whiteX) return "#3498DB"
    if (y === this.blackY && x === this.blackX) return "#E74C3C"
    return "#333333"
  },

  // 重置关卡
  onReset() {
    this.resetBtnColor = "#8E44AD"
    setTimeout(() => { this.resetBtnColor = "#9B59B6" }, 100)
    this.initLevel()
  },

  // 切换角色
  onSwitch() {
    this.currentPlayer = this.currentPlayer === 6 ? 7 : 6
    this.switchBtnColor = "#E03A5F"
    setTimeout(() => {
      this.switchBtnColor = "#FF416C"
    }, 100)
  },

  onUp() {
    this.move(0, -1)
    this.btnFlash("up")
  },
  onDown() {
    this.move(0, 1)
    this.btnFlash("down")
  },
  onLeft() {
    this.move(-1, 0)
    this.btnFlash("left")
  },
  onRight() {
    this.move(1, 0)
    this.btnFlash("right")
  },

  btnFlash(type) {
    this[`${type}BtnColor`] = "#2EB8C2"
    setTimeout(() => (this[`${type}BtnColor`] = "#36D1DC"), 100)
  },

  move(dx, dy) { 
        const isWhite = this.currentPlayer === 6 
        let [x, y] = isWhite? [this.whiteX, this.whiteY] : [this.blackX, this.blackY] 
        const [nx, ny] = [x + dx, y + dy] 
        const width = 5, height = 8 
        
        // 1. 边界检查 
        if (nx < 0 || nx >= width || ny < 0 || ny >= height) { 
            prompt.showToast({ message: "不能越界！", duration: 800 }) 
            return 
        } 

        const targetValue = this.getMapValue(ny, nx) 

        // 2. 检查是否是箱子 
        const whiteBoxIndex = this.whiteBoxes.findIndex(b => b.x === nx && b.y === ny) 
        const blackBoxIndex = this.blackBoxes.findIndex(b => b.x === nx && b.y === ny) 

        if (whiteBoxIndex !== -1 || blackBoxIndex !== -1) { 
            // --- 目标位置是箱子 --- 
            const boxColor = whiteBoxIndex !== -1? 'white' : 'black' 
            const isMyBox = (isWhite && boxColor === 'white') || (!isWhite && boxColor === 'black') 

            if (isMyBox) {
                // PUSHING OWN BOX LOGIC (推动和自己同颜色的箱子)

                const boxIndex = whiteBoxIndex !== -1? whiteBoxIndex : blackBoxIndex 
                const boxes = boxColor === 'white'? this.whiteBoxes : this.blackBoxes 

                // 计算箱子的下一个位置 
                const boxNextX = nx + dx 
                const boxNextY = ny + dy 

                // 2.1. 箱子目标位置检查：边界
                if (boxNextX < 0 || boxNextX >= width || boxNextY < 0 || boxNextY >= height) { 
                    prompt.showToast({ message: "箱子不能越界！", duration: 800 }) 
                    return 
                } 

                // 2.2. 检查箱子目标位置是否被另一个同颜色箱子占用，.some()便遍历所有箱子
                const occupiedByBox = 
                    this.whiteBoxes.some((b, i) => i !== whiteBoxIndex && b.x 
                    === boxNextX && b.y === boxNextY) | 
                    this.blackBoxes.some((b, i) => i !== blackBoxIndex && b.x 
                    === boxNextX && b.y === boxNextY)

                if (occupiedByBox) { 
                    prompt.showToast({ message: "箱子前方被阻挡！", duration: 800 }) 
                    return
                } 

                // 2.3 箱子地形限制检查
                const boxNextValue = this.getMapValue(boxNextY, boxNextX) 
                const isOnWhitePlayer = (boxNextX === this.whiteX && boxNextY === this.whiteY) 
                const isOnBlackPlayer = (boxNextX === this.blackX && boxNextY === this.blackY)

                // 白箱子只能在黑墙(1)或黑角色上移动 
                if (boxColor === 'white' && boxNextValue !== 1 && !isOnBlackPlayer) { 
                    prompt.showToast({ message: "白箱子只能在黑色地形上移动！", duration: 1000 }) 
                    return 
                } 
                // 黑箱子只能在白地(0)或白角色上移动 
                if (boxColor === 'black' && boxNextValue !== 0 && !isOnWhitePlayer) { 
                    prompt.showToast({ message: "黑箱子只能在白色地形移动！", duration: 1000 }) 
                    return
                }

                // 推动成功
                boxes[boxIndex].x = boxNextX 
                boxes[boxIndex].y = boxNextY 

                // 更新角色坐标
                if (isWhite) {
                    this.whiteX = nx
                    this.whiteY = ny
                } else {
                    this.blackX = nx
                    this.blackY = ny
                }

            } else {
                // WALKING ONTO OPPOSITE BOX LOGIC (走上相反颜色的箱子)
                // 允许移动，直接更新角色位置，不推动箱子
                 if (isWhite) {
                    this.whiteX = nx
                    this.whiteY = ny
                } else {
                    this.blackX = nx
                    this.blackY = ny
                }
            }
        } else { // 3. 检查非箱子情况：角色、箱子目标点、空地形
            // --- 非箱子情况 ---
            // 角色判断
            const otherX = isWhite ? this.blackX : this.whiteX
            const otherY = isWhite ? this.blackY : this.whiteY
            const isTargetOppositePlayer = (nx === otherX && ny === otherY)

            // 箱子目标点判断
            const isWhiteBoxTarget = this.whiteTargets.some(t => t.x === nx && t.y === ny)
            const isBlackBoxTarget = this.blackTargets.some(t => t.x === nx && t.y === ny)

            if (isWhite && (targetValue !== 1 && !isTargetOppositePlayer && !isBlackBoxTarget)) { 
                prompt.showToast({ message: "白角色只能走黑色地形！", duration: 1000 }) 
                return 
            } 
            if (!isWhite && (targetValue !== 0 && !isTargetOppositePlayer && !isWhiteBoxTarget)) { 
                prompt.showToast({ message: "黑角色只能走白色地形！", duration: 1000 }) 
                return 
            } 
            
            // 地形检查通过，更新角色坐标
            if (isWhite) {
                this.whiteX = nx
                this.whiteY = ny
            } else {
                this.blackX = nx
                this.blackY = ny
            }
        }

        this.checkWinCondition()
    }, 


  getIconColor(y, x) {
    // 角色图标颜色
    if (y === this.whiteY && x === this.whiteX) return "#333333"
    if (y === this.blackY && x === this.blackX) return "#FFFFFF"

    // 箱子图标颜色
    const hasWhiteBox = this.whiteBoxes.some(b => b.x === x && b.y === y)
    const hasBlackBox = this.blackBoxes.some(b => b.x === x && b.y === y)
        if (hasWhiteBox) return "#333333"
        if (hasBlackBox) return "#FFFFFF"
    
    // 目标点图标
    const isWhiteTarget = this.whiteTargets.some(t => t.x === x && t.y === y)
    const isBlackTarget = this.blackTargets.some(t => t.x === x && t.y === y)
          if (isWhiteTarget) return "#333333"
          if (isBlackTarget) return "#FFFFFF"
    
    return "#000000"
  },

  getIcon(y, x) {
    // 角色图标
    if (y === this.whiteY && x === this.whiteX) return "白"
    if (y === this.blackY && x === this.blackX) return "黑"
    
    // 箱子图标
    const hasWhiteBox = this.whiteBoxes.some(b => b.x === x && b.y === y)
    const hasBlackBox = this.blackBoxes.some(b => b.x === x && b.y === y)
        if (hasWhiteBox | hasBlackBox) return "箱"
    
    // 目标点图标
    const isWhiteTarget = this.whiteTargets.some(t => t.x === x && t.y === y)
    const isBlackTarget = this.blackTargets.some(t => t.x === x && t.y === y)
        if (isWhiteTarget) return "白位"
        if (isBlackTarget) return "黑位"
    return ""
  },

  checkWinCondition() {
    // 检查所有白箱子是否在白目标点上
    const whiteWin = this.whiteBoxes.every(box => 
      this.whiteTargets.some(target => target.x === box.x && target.y === box.y)
    )
    
    // 检查所有黑箱子是否在黑目标点上
    const blackWin = this.blackBoxes.every(box => 
      this.blackTargets.some(target => target.x === box.x && target.y === box.y)
    )
    
    // 所有箱子都到位
    if (whiteWin && blackWin && (this.whiteBoxes.length > 0 || this.blackBoxes.length > 0)) {
      prompt.showDialog({
        title: "恭喜通关！",
        message: "你成功将所有箱子推到目标点！",
        buttons: [
          { text: "继续", color: "#667eea" },
          { text: "重玩", color: "#FF416C" }
        ],
        success: (data) => {
          if (data.index === 1) {
            this.initLevel()
          }
        }
      })
    }
  }
}
</script>

<style scoped>
.container {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 8px;
  background-color: #1A1A1A; /* 深蓝灰背景 */
  height: 100%;
  width: 100%;
}

.title {
  font-size: 18px;
  font-weight: bold;
  color: white;
  margin: 6px 0 3px 0;
}

.info {
  background-color: #ffffff;
  padding: 5px 10px;
  border-radius: 6px;
  margin: 6px 2px;
  width: 95%;
  font-size: 12px;
}

.infoText {
  font-size: 14px;
  color: #333333;
  font-weight: bold;
  text-align: center;
}

.playerBadge {
  padding: 2px 5px;
  border-radius: 3px;
  margin: 0 3px;
}

.hint {
  font-size: 14px;
  color: #666666;
  margin-top: 3px;
  text-align: center;
}

.gameArea {
  display: flex;
  flex-direction: column;
  background-color: #1A2530; /* 深灰蓝 */
  padding: 2px;
  margin: 8px 0;
  border-radius: 4px;
}

.cell {
  width: 34px;
  height: 34px;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid #333333;
}

.row {
  display: flex;
}

.icon {
  font-size: 16px;
  font-weight: bold;
}

.playerStatus {
  display: flex;
  justify-content: space-around;
  width: 95%;
  margin: 8px 0;
}


.switchArea {
  margin-bottom: 10px;
}

.btnRow1,
.btnRow2 {
  display: flex;
  justify-content: center;
}

/* 控制区域 */
.controlArea {
  width: 100%;
  margin-top: 4px;
}

/* 切换按钮 */
.btnSwitch {
  width: 45px; /* 适配手表屏幕 */
  height: 60px;
  border: none;
  border-radius: 4px;
  display: flex; 
  align-items: center;
  justify-content: center;
  background-color: #ff416c;
  padding: 2px;
  margin: 4px;
  flex-wrap: wrap;
  text-align: center;
}

/* 方向键容器：调整为居中布局 */
.controlPanel {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: 4px;
}

/* 方向按钮：增加flex布局，确保文字居中 */
.btnArrow {
  width: 30px; 
  height: 30px;
  border: none;
  border-radius: 4px;
  margin: 1px;
  display: flex; /* 关键：让文字居中 */
  align-items: center;
  justify-content: center;
}

/* 按钮文字 */
.btnText {
  color: #ffffff;
  font-size: 14px; 
  font-weight: bold;
  text-align: center;
}

.btnReset {
  width: 25px;
  height: 60px;
  border: none;
  border-radius: 4px;
  display: flex; 
  align-items: center;
  justify-content: center;
  padding: 2px;
  margin: 4px;
}
</style>
