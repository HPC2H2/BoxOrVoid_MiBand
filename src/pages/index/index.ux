<template>
  <div class="container">
    <image class="title" src="/common/game/title.png"/>

    <!-- 游戏信息 -->
    <div class="info">
      <image class="infoText" src="/common/game/infoText.png"/>
      <image class="hint" src="/common/game/hint.png"/>
    </div>

    <!-- 画布 -->
    <div class="gameArea">
      <div class="row" for="(y, indexY) in [0, 1, 2, 3, 4, 5, 6]">
        <div class="cell" style="background-color: {{ getCellBg(y, x) }}; border-color: {{ getCellBorder(y, x) }}">
          <block if="{{ iconParts = getIconParts(y, x) }}">
            <block if="{{ !iconParts.single && iconParts.src1 && iconParts.src2 }}">
              <div class="combined-icon">
                <image class="icon" src="{{ iconParts.src1 }}" style="width: 16px; height: 16px;" />
                <image class="icon" src="{{ iconParts.src2 }}" style="width: 16px; height: 16px;" />
              </div>
            </block>
            <block elif="{{ iconParts.single && iconParts.src }}">
              <image class="icon" src="{{ iconParts.src }}" style="width: 16px; height: 16px;" />
            </block>
            <!-- 如果 src 为空或 null，不渲染任何内容 -->
          </block>
        </div>
      </div>
    </div>

    <!-- 控制区域 -->
    <div class="controlArea">
      <!-- 切换角色按钮（input不支持background-color，改为div） -->
      <div class="switchArea">
        <div
          class="btnSwitch"
          id="switchBtn"
          style="background-color: {{ switchBtnColor }}"
          onclick="onSwitch"
        >
          <text class="btnText">{{ currentPlayer === 6 ? "切换到黑" : "切换到白" }}</text>
        </div>
      </div>

      <!-- 方向键（input不支持background-color，改为div） -->
      <div class="controlPanel">
        <div class="btnRow1">
          <div class="btnArrow" style="background-color: {{ upBtnColor }}" onclick="onUp">
            <text class="btnText">↑</text>
          </div>
        </div>
        <div class="btnRow2">
          <div class="btnArrow" style="background-color: {{ leftBtnColor }}" onclick="onLeft">
            <text class="btnText">←</text>
          </div>
          <div class="btnArrow" style="background-color: {{ downBtnColor }}" onclick="onDown">
            <text class="btnText">↓</text>
          </div>
          <div class="btnArrow" style="background-color: {{ rightBtnColor }}" onclick="onRight">
            <text class="btnText">→</text>
          </div>
        </div>
      </div>
    </div>

    <div class="controlArea2">
      <!-- 重置按钮 -->
      <div class="btnReset" style="background-color: {{ resetBtnColor }}" onclick="onReset">
        <text class="btnText">重置</text>
      </div>
    </div>
  </div>
</template>

<script>
// 导入 prompt 模块
const prompt = require("@system.prompt")

export default {
  private: {
    // 疑似二维数组不触发UI更新，换一维键值对
    // 地图规则: 0=白地, 1=黑墙
    mapRules: {
      // key: "y,x", value: 0/1
    },
    whiteX: 0,
    whiteY: 1,
    blackX: 2,
    blackY: 3,
    currentPlayer: 7, // 黑
    moveCount: 0,
    // 按钮颜色
    DEFAULT_SWITCH_COLOR: "#3498DB",
    DEFAULT_RESET_COLOR: "#E74C3C",
    DEFAULT_ARROW_COLOR: "#2ECC71",
    
    switchBtnColor: "#3498DB", // 蓝色：切换
    upBtnColor: "#2ECC71", // 绿色：向上
    downBtnColor: "#2ECC71",
    leftBtnColor: "#2ECC71",
    rightBtnColor: "#2ECC71",
    resetBtnColor: "#E74C3C", // 红色：重置

    // 箱子数据
    whiteBoxes: [],
    blackBoxes: [],
    // 箱子目标点
    whiteBoxTargets: [],
    blackBoxTargets: [],

    // 角色目标点
    whitePlayerTarget: [],
    blackPlayerTarget: [],
  },

  onInit() {
    this.initLevel()
  },

  initLevel() {
    this.initMapRules()
    this.initBoxes()
    this.initTargets()
  },
  initBoxes() {
    // 白箱子只能在黑色地形上移动
    this.whiteBoxes = [
      {x: 1, y: 2},
      {x: 2, y: 1}
    ]
    // 黑箱子只能在白色地形上移动
    this.blackBoxes = [{x: 1, y: 4}]
  },

  initTargets() {
    // 1.箱子目标点
    // 白箱子目标点(在黑色位置)
    this.whiteBoxTargets = [
      {x: 1, y: 6},
      {x: 3, y: 6}
    ]
    // 黑箱子目标点
    this.blackBoxTargets = [{x: 3, y: 3}]

    // 2. 角色目标点
    // 白角色目标点(在黑色位置)
    this.whitePlayerTarget = [{x: 1, y: 5}]

    // 黑角色目标点
    this.blackPlayerTarget = [{x: 4, y: 2}]
  },

  initMapRules() {
    const width = 5,
      height = 7
    this.mapRules = {}

    // 1. 所有位置默认白地（0）
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        this.mapRules[y + "," + x] = 0
      }
    }

    // 2. 四周黑墙(1)
    for (let x = 0; x < width; x++) {
      this.mapRules[0 + "," + x] = 1 //顶部
      this.mapRules[height - 1 + "," + x] = 1 //底部
    }

    for (let y = 0; y < height; y++) {
      this.mapRules[y + "," + 0] = 1 //左边
      this.mapRules[y + "," + (width - 1)] = 1 //右边
    }

    // 3. 内部黑墙
    this.mapRules["1,2"] = 1
    this.mapRules["2,2"] = 1
    this.mapRules["1,4"] = 1
    this.mapRules["2,4"] = 1

    // 4. 初始化角色位置
    this.whiteX = 0
    this.whiteY = 1
    this.blackX = 2
    this.blackY = 3
  },

  getMapValue(y, x) {
    return this.mapRules[y + "," + x] || 0
  },

  // 返回画布中单元格背景颜色
  getCellBg(y, x) {
    const isWhiteBoxTarget = this.whiteBoxTargets.some((t) => t.x === x && t.y === y)
    const isBlackBoxTarget = this.blackBoxTargets.some((t) => t.x === x && t.y === y)
    const hasWhiteBox = this.whiteBoxes.some((b) => b.x === x && b.y === y)
    const hasBlackBox = this.blackBoxes.some((b) => b.x === x && b.y === y)
  
    // 优先级: 角色 > 箱子 > 箱子目标点 > 地图
    if (y === this.whiteY && x === this.whiteX) return "#FFFFFF"
    if (y === this.blackY && x === this.blackX) return "#000000"
    if (hasWhiteBox) return "#E0E0E0"
    if (hasBlackBox) return "#1A1A1A"
    if (isWhiteBoxTarget) return "#FCD3D3"
    if (isBlackBoxTarget) return "#333333"
  
  // 角色目标点
  // 白位的坐标
  const whitePosition = {x: 1, y: 5}; 
  // 黑位的坐标
  const blackPosition = {x: 4, y: 2};

  if (y === whitePosition.y && x === whitePosition.x) return "#D3D3D3"; // 设置白位的背景颜色为浅灰色
  if (y === blackPosition.y && x === blackPosition.x) return "#555555"; // 设置黑位的背景颜色为中灰色


    return this.getMapValue(y, x) === 0 ? "#F8F9FA" : "#2D3748"
  },

  // 返回画布中单元格边框颜色
  getCellBorder(y, x) {
    if (y === this.whiteY && x === this.whiteX) return "#3498DB"
    if (y === this.blackY && x === this.blackX) return "#E74C3C"
    return "#333333"
  },

  // 重置关卡
  onReset() {
    
    // 恢复游戏初始状态
    this.initLevel();
    
    // 设置新的颜色
    this.resetBtnColor = "#9B59B6";
    
    // 在设定的时间后，恢复原始颜色
    setTimeout(() => {
      this.resetBtnColor = this.DEFAULT_RESET_COLOR;
    }, 500); 
  },

  // 切换角色
  onSwitch() {
    this.currentPlayer = this.currentPlayer === 6 ? 7 : 6;
    
    // 设置新的颜色
    this.switchBtnColor = "#FF416C";
    
    // 在设定的时间后，恢复原始颜色
    setTimeout(() => {
      this.switchBtnColor = this.DEFAULT_SWITCH_COLOR;
    }, 500);
  },

  onUp() {
    this.move(0, -1)
    this.btnFlash("up")
  },
  onDown() {
    this.move(0, 1)
    this.btnFlash("down")
  },
  onLeft() {
    this.move(-1, 0)
    this.btnFlash("left")
  },
  onRight() {
    this.move(1, 0)
    this.btnFlash("right")
  },

  btnFlash(type) {
    // 设置新的颜色
    this[`${type}BtnColor`] = "#36D1DC";
    
    // 在设定的时间后，恢复原始颜色
    setTimeout(() => {
      this[`${type}BtnColor`] = this.DEFAULT_ARROW_COLOR;
    }, 200); 
  },

  move(dx, dy) {
    const isWhite = this.currentPlayer === 6;
    const [x, y] = isWhite ? [this.whiteX, this.whiteY] : [this.blackX, this.blackY];
    const [nx, ny] = [x + dx, y + dy];
    const width = 5, height = 7;

    // 1. 边界检查
    if (nx < 0 || nx >= width || ny < 0 || ny >= height) {
      prompt.showToast({ message: "不能越界！", duration: 800 });
      return;
    }

    // 2. 获取目标地形和状态
    const targetValue = this.getMapValue(ny, nx);
    const otherX = isWhite ? this.blackX : this.whiteX;
    const otherY = isWhite ? this.blackY : this.whiteY;
    const isTargetOppositePlayer = nx === otherX && ny === otherY;

    const isWhiteBoxTarget = this.whiteBoxTargets.some(t => t.x === nx && t.y === ny);
    const isBlackBoxTarget = this.blackBoxTargets.some(t => t.x === nx && t.y === ny);

    const hasWhiteBox = this.whiteBoxes.some(b => b.x === nx && b.y === ny);
    const hasBlackBox = this.blackBoxes.some(b => b.x === nx && b.y === ny);

    // 3. 地形合法性检查（角色只能走特定地形）
    if (isWhite) {
      // 白角色可以走：黑地（1）、黑箱子、黑目标点、对方角色位置
      if (targetValue !== 1 && !hasBlackBox && !isBlackBoxTarget && !isTargetOppositePlayer) {
        prompt.showToast({ message: "白角色只能走黑色地形！", duration: 1000 });
        return;
      }
    } else {
      // 黑角色可以走：白地（0）、白箱子、白目标点、对方角色位置
      if (targetValue !== 0 && !hasWhiteBox && !isWhiteBoxTarget && !isTargetOppositePlayer) {
        prompt.showToast({ message: "黑角色只能走白色地形！", duration: 1000 });
        return;
      }
    }

    // 4. 检查目标格是否有箱子
    const whiteBoxIndex = this.whiteBoxes.findIndex(b => b.x === nx && b.y === ny);
    const blackBoxIndex = this.blackBoxes.findIndex(b => b.x === nx && b.y === ny);

    let moved = false;

    // 5. 如果有白箱子
    if (whiteBoxIndex !== -1) {
      if (isWhite) {
        // 白角色推白箱子
        const boxNextX = nx + dx;
        const boxNextY = ny + dy;

        // 箱子边界检查
        if (boxNextX < 0 || boxNextX >= width || boxNextY < 0 || boxNextY >= height) {
          prompt.showToast({ message: "箱子不能越界！", duration: 800 });
          return;
        }

        // 检查箱子前方是否被阻挡（其他箱子或角色）
        const blockedByWhite = this.whiteBoxes.some((b, i) => i !== whiteBoxIndex && b.x === boxNextX && b.y === boxNextY);
        const blockedByBlack = this.blackBoxes.some(b => b.x === boxNextX && b.y === boxNextY);
        const blockedByPlayer = (boxNextX === this.whiteX && boxNextY === this.whiteY) ||
                              (boxNextX === this.blackX && boxNextY === this.blackY);

        if (blockedByWhite || blockedByBlack || blockedByPlayer) {
          prompt.showToast({ message: "箱子前方被阻挡！", duration: 800 });
          return;
        }

        // 检查箱子目标地形
        const boxNextValue = this.getMapValue(boxNextY, boxNextX);
        const onBlackTarget = this.blackBoxTargets.some(t => t.x === boxNextX && t.y === boxNextY);

        if (boxNextValue !== 1 && !onBlackTarget) {
          prompt.showToast({ message: "白箱子只能在黑色地形上移动！", duration: 1000 });
          return;
        }

        // 推动成功
        this.whiteBoxes[whiteBoxIndex].x = boxNextX;
        this.whiteBoxes[whiteBoxIndex].y = boxNextY;
        this.whiteX = nx;
        this.whiteY = ny;
        moved = true;
      } else {
        // 黑角色走上白箱子（允许）
        this.blackX = nx;
        this.blackY = ny;
        moved = true;
      }
    }
    // 6. 如果有黑箱子（且没有白箱子）
    else if (blackBoxIndex !== -1) {
      if (!isWhite) {
        // 黑角色推黑箱子
        const boxNextX = nx + dx;
        const boxNextY = ny + dy;

        if (boxNextX < 0 || boxNextX >= width || boxNextY < 0 || boxNextY >= height) {
          prompt.showToast({ message: "箱子不能越界！", duration: 800 });
          return;
        }

        const blockedByBlack = this.blackBoxes.some((b, i) => i !== blackBoxIndex && b.x === boxNextX && b.y === boxNextY);
        const blockedByWhite = this.whiteBoxes.some(b => b.x === boxNextX && b.y === boxNextY);
        const blockedByPlayer = (boxNextX === this.whiteX && boxNextY === this.whiteY) ||
                              (boxNextX === this.blackX && boxNextY === this.blackY);

        if (blockedByWhite || blockedByBlack || blockedByPlayer) {
          prompt.showToast({ message: "箱子前方被阻挡！", duration: 800 });
          return;
        }

        const boxNextValue = this.getMapValue(boxNextY, boxNextX);
        const onWhiteTarget = this.whiteBoxTargets.some(t => t.x === boxNextX && t.y === boxNextY);

        if (boxNextValue !== 0 && !onWhiteTarget) {
          prompt.showToast({ message: "黑箱子只能在白色地形上移动！", duration: 1000 });
          return;
        }

        this.blackBoxes[blackBoxIndex].x = boxNextX;
        this.blackBoxes[blackBoxIndex].y = boxNextY;
        this.blackX = nx;
        this.blackY = ny;
        moved = true;
      } else {
        // 白角色走上黑箱子（允许）
        this.whiteX = nx;
        this.whiteY = ny;
        moved = true;
      }
    }

    // 7. 如果没有箱子，直接移动
    if (!moved) {
      if (isWhite) {
        this.whiteX = nx;
        this.whiteY = ny;
      } else {
        this.blackX = nx;
        this.blackY = ny;
      }
    }

    this.checkWinCondition();
  },

  getIconColor(y, x) {
    // 角色图标颜色
    if (y === this.whiteY && x === this.whiteX) return "#333333"
    if (y === this.blackY && x === this.blackX) return "#FFFFFF"

    // 箱子图标颜色
    const hasWhiteBox = this.whiteBoxes.some((b) => b.x === x && b.y === y)
    const hasBlackBox = this.blackBoxes.some((b) => b.x === x && b.y === y)
    if (hasWhiteBox) return "#333333"
    if (hasBlackBox) return "#FFFFFF"

    // 箱子目标点图标
    const isWhiteBoxTarget = this.whiteBoxTargets.some((t) => t.x === x && t.y === y)
    const isBlackBoxTarget = this.blackBoxTargets.some((t) => t.x === x && t.y === y)
    if (isWhiteBoxTarget) return "#333333"
    if (isBlackBoxTarget) return "#FFFFFF"

    // 角色目标点图标
    const whitePosition = {x: 1, y: 5};
    const blackPosition = {x: 4, y: 2};
    if (y === whitePosition.y && x === whitePosition.x) return "#333333";
    if (y === blackPosition.y && x === blackPosition.x) return "#FFFFFF";

    return "#000000"
  },

  getIconType(y, x) {
    // 角色
    if (y === this.whiteY && x === this.whiteX) return "white-player";
    if (y === this.blackY && x === this.blackX) return "black-player";

    // 箱子
    const hasWhiteBox = this.whiteBoxes.some(b => b.x === x && b.y === y);
    const hasBlackBox = this.blackBoxes.some(b => b.x === x && b.y === y);
    if (hasWhiteBox) return "white-box";
    if (hasBlackBox) return "black-box";

    // 箱子目标点
    const isWhiteBoxTarget = this.whiteBoxTargets.some(t => t.x === x && t.y === y);
    const isBlackBoxTarget = this.blackBoxTargets.some(t => t.x === x && t.y === y);
    if (isWhiteBoxTarget) return "white-box-white-target";
    if (isBlackBoxTarget) return "black-box-black-target";

    // 角色目标点
    const whitePosition = {x: 1, y: 5};
    const blackPosition = {x: 4, y: 2};
    if (y === whitePosition.y && x === whitePosition.x) return "white-player-white-target";
    if (y === blackPosition.y && x === blackPosition.x) return "black-player-black-target";

    return null; // 无图标
  },

  // 返回 { single: true, src: "..." } 或 { single: false, src1: "...", src2: "..." }
  getIconParts(y, x) {
    const type = this.getIconType(y, x);
    if (!type) {
      return { single: true, src: null }; // 无图标
    }

    const parts = type.split('-');
    // 判断是否需要拆分：只有当有 3 个 '-'（即 parts.length === 4）时才拆
    if (parts.length === 4) {
      // 按第2个'-'（从0开始是索引2）拆：前2段 + 后2段
      const firstPart = parts[0] + '-' + parts[1];   // e.g. "white-box"
      const secondPart = parts[2] + '-' + parts[3];  // e.g. "white-target"
      return {
        single: false,
        src1: this.getIconImagePath(firstPart),
        src2: this.getIconImagePath(secondPart)
      };
    } else {
      // 单图标
      return {
        single: true,
        src: this.getIconImagePath(type)
      };
    }
  },

  getIconImagePath(type) {
  const icons = {
    "white-player": "/common/game/icons/white.png",
    "black-player": "/common/game/icons/black.png",
    "white-box": "/common/game/icons/white_box.png",
    "black-box": "/common/game/icons/black_box.png",
    "white-target": "/common/game/icons/white_target.png",
    "black-target": "/common/game/icons/black_target.png",
  };
  return icons[type] || "";
},

  checkWinCondition() {
    // 检查所有白箱子是否在白目标点上
    const whiteWin = this.whiteBoxes.every((box) =>
      this.whiteBoxTargets.some((target) => target.x === box.x && target.y === box.y)
    )

    // 检查所有黑箱子是否在黑目标点上
    const blackWin = this.blackBoxes.every((box) =>
      this.blackBoxTargets.some((target) => target.x === box.x && target.y === box.y)
    )

    // 所有箱子都到位
    if (whiteWin && blackWin && (this.whiteBoxes.length > 0 || this.blackBoxes.length > 0)) {
      prompt.showDialog({
        title: "恭喜通关！",
        message: "你成功将所有箱子推到目标点！",
        buttons: [
          {text: "继续", color: "#667eea"},
          {text: "重玩", color: "#FF416C"}
        ],
        success: (data) => {
          if (data.index === 1) {
            this.initLevel()
          }
        }
      })
    }
  }
}
</script>

<style scoped>
.container {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 8px;
  background-color: #1a1a1a; /* 深蓝灰背景 */
  height: 100%;
  width: 100%;
}

.title {
  background-color: #1a1a1a;
  height:30px;
  width: 70%;
  object-fit: fill;
  margin: 6px 0 3px 0;
}

.info {
  background-color: #ffffff;
  display: flex;
  justify-content: space-between;
  margin: 2px;
  border-radius: 6px;
  overflow: hidden; /* 隐藏超出边界的图片内容 */
}

.infoText, .hint {
  height: 40px; /* 统一高度 */
  width: 100%;
  object-fit: fill; /* 保持比例，填充整个区域 */
  border-radius: inherit;
}

.gameArea {
  display: flex;
  flex-direction: column;
  background-color: #1a2530; /* 深灰蓝 */
  padding: 2px;
  margin: 8px 0;
  border-radius: 4px;
}

.cell {
  width: 34px;
  height: 34px;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid #333333;
}

.row {
  display: flex;
}

.icon {
  font-size: 16px;
  font-weight: bold;
}

.switchArea {
  margin-bottom: 10px;
}

.btnRow1,
.btnRow2 {
  display: flex;
  justify-content: center;
}

/* 控制区域 */
.controlArea {
  width: 100%;
  margin-top: 4px;
}

/* 切换按钮 */
.btnSwitch {
  width: 45px; /* 适配手表屏幕 */
  height: 60px;
  border: none;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #ff416c;
  padding: 2px;
  margin: 4px;
  flex-wrap: wrap;
  text-align: center;
}

/* 方向键容器：调整为居中布局 */
.controlPanel {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: 4px;
}

/* 方向按钮：增加flex布局，确保文字居中 */
.btnArrow {
  width: 30px;
  height: 30px;
  border: none;
  border-radius: 4px;
  margin: 1px;
  display: flex; /* 关键：让文字居中 */
  align-items: center;
  justify-content: center;
}

/* 按钮文字 */
.btnText {
  color: #ffffff;
  font-size: 14px;
  font-weight: bold;
  text-align: center;
}

.btnReset {
  width: 45px;
  height: 40px;
  border: none;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #e74c3c;
  padding: 2px;
  margin: 4px;
  font-size: 12px;
  color: white;
  text-align: center;
}

.combined-icon {
  display: flex;
  align-items: center;
  gap: 1px; /* 小间距 */
}

.icon {
  width: 16px;
  height: 16px;
}

</style>
