<template>
  <div class="container">
    <image class="title" src="/common/game/title.png" />

    <!-- 游戏信息 -->
    <div class="info">
      <image class="infoText" src="/common/game/infoText.png" />
      <image class="hint" src="/common/game/hint.png" />
    </div>

    <!-- 画布 -->
    <div class="gameArea">
      <div class="row" for="(y, indexY) in [0,1,2,3,4,5,6]">
        <div
          class="cell"
          style="background-color: {{ getCellBg(y, x) }}; border-color: {{ getCellBorder(y, x) }}"
          for="(x, indexX) in [0,1,2,3,4]"
        >
          <!-- 直接从预计算的数据中取 -->
          <block if="{{ cellIcons[y + ',' + x] && !cellIcons[y + ',' + x].single && cellIcons[y + ',' + x].src1 && cellIcons[y + ',' + x].src2 }}">
            <div class="combined-icon">
              <image class="icon" src="{{ cellIcons[y + ',' + x].src1 }}" style="width: 16px; height: 16px" />
              <image class="icon" src="{{ cellIcons[y + ',' + x].src2 }}" style="width: 16px; height: 16px" />
            </div>
          </block>
          <block elif="{{ cellIcons[y + ',' + x] && cellIcons[y + ',' + x].single && cellIcons[y + ',' + x].src }}">
            <image class="icon" src="{{ cellIcons[y + ',' + x].src }}" style="width: 20px; height: 20px" />
          </block>
        </div>
      </div>
    </div>

    <!-- 控制区域 -->
    <div class="controlArea">
      <!-- 切换角色按钮（input不支持background-color，改为div） -->
      <div class="switchArea">
        <div
          class="btnSwitch"
          id="switchBtn"
          style="background-color: {{ switchBtnColor }}"
          onclick="onSwitch"
        >
          <div class="icon-row">
            <image class="icon" src="/common/game/icons/white-qie.png" />
            <image class="icon" src="/common/game/icons/white-huan.png" />
          </div>
          <div class="icon-row">
            <image class="icon" src="/common/game/icons/white-dao.png" />
            <block if="{{ currentPlayer === 7 }}">
              <image class="icon" src="/common/game/icons/white-white.png" />
            </block>
            <block if="{{ currentPlayer === 6 }}">
              <image class="icon" src="/common/game/icons/white-black.png" />
            </block>
          </div>
        </div>
      </div>

      <!-- 方向键（input不支持background-color，改为div） -->
      <div class="controlPanel">
        <div class="btnRow1">
          <div class="btnArrow" style="background-color: {{ upBtnColor }}" onclick="onUp">
            <image src="/common/game/icons/white-up-arrow.png" style="width: 20px; height: 20px" />
            <!-- <text class="btnText">↑</text> -->
          </div>
        </div>
        <div class="btnRow2">
          <div class="btnArrow" style="background-color: {{ leftBtnColor }}" onclick="onLeft">
            <image src="/common/game/icons/white-left-arrow.png" style="width: 20px; height: 20px" />
            <!-- <text class="btnText">←</text> -->
          </div>
          <div class="btnArrow" style="background-color: {{ downBtnColor }}" onclick="onDown">
            <image src="/common/game/icons/white-down-arrow.png" style="width: 20px; height: 20px" />
            <!-- <text class="btnText">↓</text> -->
          </div>
          <div class="btnArrow" style="background-color: {{ rightBtnColor }}" onclick="onRight">
            <image src="/common/game/icons/white-right-arrow.png" style="width: 20px; height: 20px" />
            <!-- <text class="btnText">→</text> -->
          </div>
        </div>
      </div>
    </div>

    <div class="controlArea2">
      <!-- 重置按钮 -->
      <div class="btnReset" style="background-color: {{ resetBtnColor }}" onclick="onReset">
        <image
          class="resetImage"
          src="/common/game/icons/white-chong.png"
          style="width: 20px; height: 20px"
        />
        <image
          class="resetImage"
          src="/common/game/icons/white-zhi.png"
          style="width: 20px; height: 20px"
        />
      </div>
    </div>
  </div>
</template>

<script>
// 导入 prompt 模块
const prompt = require("@system.prompt")

export default {
  private: {
    // 疑似二维数组不触发UI更新，换一维键值对
    // 地图规则: 0=白地, 1=黑墙
    mapRules: {
      // key: "y,x", value: 0/1
    },
    whiteX: 0,
    whiteY: 1,
    blackX: 2,
    blackY: 3,
    currentPlayer: 7, // 黑

    // 按钮颜色
    DEFAULT_SWITCH_COLOR: "#3498DB",
    DEFAULT_RESET_COLOR: "#E74C3C",
    DEFAULT_ARROW_COLOR: "#2ECC71",

    switchBtnColor: "#3498DB", // 蓝色：切换
    upBtnColor: "#2ECC71", // 绿色：向上
    downBtnColor: "#2ECC71",
    leftBtnColor: "#2ECC71",
    rightBtnColor: "#2ECC71",
    resetBtnColor: "#E74C3C", // 红色：重置

    // 箱子数据
    whiteBoxes: [],
    blackBoxes: [],
    // 箱子目标点
    whiteBoxTargets: [],
    blackBoxTargets: [],

    // 角色目标点
    whitePlayerTarget: [],
    blackPlayerTarget: [],

    cellIcons: {},
  },

  // 新增方法：刷新所有单元格的图标数据
  updateCellIcons() {
    const icons = {};
    for (let y = 0; y < 7; y++) {
      for (let x = 0; x < 5; x++) {
        const parts = this.getIconParts(y, x);
        // 注意：即使 src 为 null，也要存，否则模板可能无法响应变化
        icons[`${y},${x}`] = parts;
      }
    }
    this.cellIcons = icons; // 触发视图更新
  },

  onInit() {
    this.initLevel()
    this.updateCellIcons(); // 初始化图标
  },

  initLevel() {
    this.initMapRules()
    this.initBoxes()
    this.initTargets()
  },
  initBoxes() {
    // 白箱子只能在黑色地形上移动
    this.whiteBoxes = [
      {x: 1, y: 2},
      {x: 2, y: 1}
    ]
    // 黑箱子只能在白色地形上移动
    this.blackBoxes = [{x: 1, y: 4}]
  },

  initTargets() {
    // 1.箱子目标点
    // 白箱子目标点(在黑色位置)
    this.whiteBoxTargets = [
      {x: 1, y: 6},
      {x: 3, y: 6}
    ]
    // 黑箱子目标点
    this.blackBoxTargets = [{x: 3, y: 3}]

    // 2. 角色目标点
    // 白角色目标点(在黑色位置)
    this.whitePlayerTarget = [{x: 1, y: 5}]

    // 黑角色目标点
    this.blackPlayerTarget = [{x: 4, y: 2}]
  },

  initMapRules() {
    const width = 5,
      height = 7
    this.mapRules = {}

    // 1. 所有位置默认白地（0）
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        this.mapRules[y + "," + x] = 0
      }
    }

    // 2. 四周黑墙(1)
    for (let x = 0; x < width; x++) {
      this.mapRules[0 + "," + x] = 1 //顶部
      this.mapRules[height - 1 + "," + x] = 1 //底部
    }

    for (let y = 0; y < height; y++) {
      this.mapRules[y + "," + 0] = 1 //左边
      this.mapRules[y + "," + (width - 1)] = 1 //右边
    }

    // 3. 内部黑墙
    this.mapRules["1,2"] = 1
    this.mapRules["2,2"] = 1
    this.mapRules["1,4"] = 1
    this.mapRules["2,4"] = 1

    // 4. 初始化角色位置
    this.whiteX = 4
    this.whiteY = 1
    this.blackX = 2
    this.blackY = 3
  },

  getMapValue(y, x) {
    return this.mapRules[y + "," + x] || 0
  },

  // 返回画布中单元格背景颜色
  getCellBg(y, x) {
    const isWhiteBoxTarget = this.whiteBoxTargets.some((t) => t.x === x && t.y === y)
    const isBlackBoxTarget = this.blackBoxTargets.some((t) => t.x === x && t.y === y)
    const hasWhiteBox = this.whiteBoxes.some((b) => b.x === x && b.y === y)
    const hasBlackBox = this.blackBoxes.some((b) => b.x === x && b.y === y)

    // 优先级: 角色 > 箱子 > 箱子目标点 > 地图
    if (y === this.whiteY && x === this.whiteX) return "#FFFFFF"
    if (y === this.blackY && x === this.blackX) return "#000000"
    if (hasWhiteBox) return "#E0E0E0"
    if (hasBlackBox) return "#1A1A1A"
    if (isWhiteBoxTarget) return "#FCD3D3"
    if (isBlackBoxTarget) return "#333333"

    // 角色目标点
    // 白位的坐标
    const whitePosition = {x: 1, y: 5}
    // 黑位的坐标
    const blackPosition = {x: 4, y: 2}

    if (y === whitePosition.y && x === whitePosition.x) return "#D3D3D3" // 设置白位的背景颜色为浅灰色
    if (y === blackPosition.y && x === blackPosition.x) return "#555555" // 设置黑位的背景颜色为中灰色

    return this.getMapValue(y, x) === 0 ? "#F8F9FA" : "#2D3748"
  },

  // 返回画布中单元格边框颜色
  getCellBorder(y, x) {
    if (y === this.whiteY && x === this.whiteX) return "#3498DB"
    if (y === this.blackY && x === this.blackX) return "#E74C3C"
    return "#333333"
  },

  // 重置关卡
  onReset() {
    // 恢复游戏初始状态
    this.initLevel()

    // 设置新的颜色
    this.resetBtnColor = "#9B59B6"

    // 在设定的时间后，恢复原始颜色
    setTimeout(() => {
      this.resetBtnColor = this.DEFAULT_RESET_COLOR
    }, 500)

    this.updateCellIcons(); // 重置后也要更新图标显示
  },

  // 切换角色
  onSwitch() {
    this.currentPlayer = this.currentPlayer === 6 ? 7 : 6

    // 设置新的颜色
    this.switchBtnColor = "#FF416C"

    // 在设定的时间后，恢复原始颜色
    setTimeout(() => {
      this.switchBtnColor = this.DEFAULT_SWITCH_COLOR
    }, 500)
  },

  onUp() {
    this.move(0, -1)
    this.btnFlash("up")
  },
  onDown() {
    this.move(0, 1)
    this.btnFlash("down")
  },
  onLeft() {
    this.move(-1, 0)
    this.btnFlash("left")
  },
  onRight() {
    this.move(1, 0)
    this.btnFlash("right")
  },

  btnFlash(type) {
    // 设置新的颜色
    this[`${type}BtnColor`] = "#36D1DC"

    // 在设定的时间后，恢复原始颜色
    setTimeout(() => {
      this[`${type}BtnColor`] = this.DEFAULT_ARROW_COLOR
    }, 200)
  },

  move(dx, dy) {
    const isWhite = this.currentPlayer === 6
    const [x, y] = isWhite ? [this.whiteX, this.whiteY] : [this.blackX, this.blackY]
    const [nx, ny] = [x + dx, y + dy]
    const width = 5,
      height = 7

    // 1. 边界检查
    if (nx < 0 || nx >= width || ny < 0 || ny >= height) {
      prompt.showToast({message: "不能越界！", duration: 800})
      return
    }

    // 2. 获取目标地形和状态
    const targetValue = this.getMapValue(ny, nx)
    const otherX = isWhite ? this.blackX : this.whiteX
    const otherY = isWhite ? this.blackY : this.whiteY
    const isTargetOppositePlayer = nx === otherX && ny === otherY

    const isWhiteBoxTarget = this.whiteBoxTargets.some((t) => t.x === nx && t.y === ny)
    const isBlackBoxTarget = this.blackBoxTargets.some((t) => t.x === nx && t.y === ny)

    const hasWhiteBox = this.whiteBoxes.some((b) => b.x === nx && b.y === ny)
    const hasBlackBox = this.blackBoxes.some((b) => b.x === nx && b.y === ny)

    // 3. 地形合法性检查（角色只能走特定地形）
    if (isWhite) {
      // 白角色可以走：黑地（1）、黑箱子、黑目标点、对方角色位置
      if (targetValue !== 1 && !hasBlackBox && !isBlackBoxTarget && !isTargetOppositePlayer) {
        prompt.showToast({message: "白角色只能走黑色地形！", duration: 1000})
        return
      }
    } else {
      // 黑角色可以走：白地（0）、白箱子、白目标点、对方角色位置
      if (targetValue !== 0 && !hasWhiteBox && !isWhiteBoxTarget && !isTargetOppositePlayer) {
        prompt.showToast({message: "黑角色只能走白色地形！", duration: 1000})
        return
      }
    }

    // 4. 检查目标格是否有箱子
    const whiteBoxIndex = this.whiteBoxes.findIndex((b) => b.x === nx && b.y === ny)
    const blackBoxIndex = this.blackBoxes.findIndex((b) => b.x === nx && b.y === ny)

    let moved = false

    // 5. 如果有白箱子
    if (whiteBoxIndex !== -1) {
      if (isWhite) {
        // 白角色推白箱子
        const boxNextX = nx + dx
        const boxNextY = ny + dy

        // 箱子边界检查
        if (boxNextX < 0 || boxNextX >= width || boxNextY < 0 || boxNextY >= height) {
          prompt.showToast({message: "箱子不能越界！", duration: 800})
          return
        }

        // 检查箱子前方是否被阻挡（其他箱子或角色）
        const blockedByWhite = this.whiteBoxes.some(
          (b, i) => i !== whiteBoxIndex && b.x === boxNextX && b.y === boxNextY
        )
        const blockedByBlack = this.blackBoxes.some((b) => b.x === boxNextX && b.y === boxNextY)
        const blockedByPlayer =
          (boxNextX === this.whiteX && boxNextY === this.whiteY) ||
          (boxNextX === this.blackX && boxNextY === this.blackY)

        if (blockedByWhite || blockedByBlack || blockedByPlayer) {
          prompt.showToast({message: "箱子前方被阻挡！", duration: 800})
          return
        }

        // 检查箱子目标地形
        const boxNextValue = this.getMapValue(boxNextY, boxNextX)
        const onBlackTarget = this.blackBoxTargets.some((t) => t.x === boxNextX && t.y === boxNextY)

        if (boxNextValue !== 1 && !onBlackTarget) {
          prompt.showToast({message: "白箱子只能在黑色地形上移动！", duration: 1000})
          return
        }

        // 推动成功
        this.whiteBoxes[whiteBoxIndex].x = boxNextX
        this.whiteBoxes[whiteBoxIndex].y = boxNextY
        this.whiteX = nx
        this.whiteY = ny
        moved = true
      } else {
        // 黑角色走上白箱子（允许）
        this.blackX = nx
        this.blackY = ny
        moved = true
      }
    }
    // 6. 如果有黑箱子（且没有白箱子）
    else if (blackBoxIndex !== -1) {
      if (!isWhite) {
        // 黑角色推黑箱子
        const boxNextX = nx + dx
        const boxNextY = ny + dy

        if (boxNextX < 0 || boxNextX >= width || boxNextY < 0 || boxNextY >= height) {
          prompt.showToast({message: "箱子不能越界！", duration: 800})
          return
        }

        const blockedByBlack = this.blackBoxes.some(
          (b, i) => i !== blackBoxIndex && b.x === boxNextX && b.y === boxNextY
        )
        const blockedByWhite = this.whiteBoxes.some((b) => b.x === boxNextX && b.y === boxNextY)
        const blockedByPlayer =
          (boxNextX === this.whiteX && boxNextY === this.whiteY) ||
          (boxNextX === this.blackX && boxNextY === this.blackY)

        if (blockedByWhite || blockedByBlack || blockedByPlayer) {
          prompt.showToast({message: "箱子前方被阻挡！", duration: 800})
          return
        }

        const boxNextValue = this.getMapValue(boxNextY, boxNextX)
        const onWhiteTarget = this.whiteBoxTargets.some((t) => t.x === boxNextX && t.y === boxNextY)

        if (boxNextValue !== 0 && !onWhiteTarget) {
          prompt.showToast({message: "黑箱子只能在白色地形上移动！", duration: 1000})
          return
        }

        this.blackBoxes[blackBoxIndex].x = boxNextX
        this.blackBoxes[blackBoxIndex].y = boxNextY
        this.blackX = nx
        this.blackY = ny
        moved = true
      } else {
        // 白角色走上黑箱子（允许）
        this.whiteX = nx
        this.whiteY = ny
        moved = true
      }
    }

    // 7. 如果没有箱子，直接移动
    if (!moved) {
      if (isWhite) {
        this.whiteX = nx
        this.whiteY = ny
      } else {
        this.blackX = nx
        this.blackY = ny
      }
    }

    this.checkWinCondition()

    this.updateCellIcons(); // 更新图标显示
  },

  getIconColor(y, x) {
    // 角色图标颜色
    if (y === this.whiteY && x === this.whiteX) return "#333333"
    if (y === this.blackY && x === this.blackX) return "#FFFFFF"

    // 箱子图标颜色
    const hasWhiteBox = this.whiteBoxes.some((b) => b.x === x && b.y === y)
    const hasBlackBox = this.blackBoxes.some((b) => b.x === x && b.y === y)
    if (hasWhiteBox) return "#333333"
    if (hasBlackBox) return "#FFFFFF"

    // 箱子目标点图标
    const isWhiteBoxTarget = this.whiteBoxTargets.some((t) => t.x === x && t.y === y)
    const isBlackBoxTarget = this.blackBoxTargets.some((t) => t.x === x && t.y === y)
    if (isWhiteBoxTarget) return "#333333"
    if (isBlackBoxTarget) return "#FFFFFF"

    // 角色目标点图标
    const whitePosition = {x: 1, y: 5}
    const blackPosition = {x: 4, y: 2}
    if (y === whitePosition.y && x === whitePosition.x) return "#333333"
    if (y === blackPosition.y && x === blackPosition.x) return "#FFFFFF"

    return "#000000"
  },

  getIconType(y, x) {
    // console.log(`getIconType called for (${y},${x})`);
    // console.log(`白角色位置: (${this.whiteY},${this.whiteX})`);
    // console.log(`黑角色位置: (${this.blackY},${this.blackX})`);
    // 角色：白角色
    if (y === this.whiteY && x === this.whiteX) {
      // console.log(`白角色位置匹配: (${y},${x})`);
      return "white-player"
    }
    // 角色：黑角色
    if (y === this.blackY && x === this.blackX) {
      // console.log(`黑角色位置匹配: (${y},${x})`);
      return "black-player"
    }

    // 白箱子
    const whiteBox = this.whiteBoxes.find((b) => b.x === x && b.y === y)
    if (whiteBox) {
      return "white-box"
    }

    // 黑箱子
    const blackBox = this.blackBoxes.find((b) => b.x === x && b.y === y)
    if (blackBox) {
      return "black-box"
    }

    // 箱子目标点（仅当无箱子时才显示）
    const isWhiteBoxTarget = this.whiteBoxTargets.some((t) => t.x === x && t.y === y)
    if (isWhiteBoxTarget) {
      return "white-box-white-target"
    }

    const isBlackBoxTarget = this.blackBoxTargets.some((t) => t.x === x && t.y === y)
    if (isBlackBoxTarget) {
      return "black-box-black-target"
    }

    // 角色目标点（仅当无角色时才显示）
    const whitePosition = {x: 1, y: 5}
    if (y === whitePosition.y && x === whitePosition.x) {
      return "white-player-white-target"
    }

    const blackPosition = {x: 4, y: 2}
    if (y === blackPosition.y && x === blackPosition.x) {
      return "black-player-black-target"
    }

    return null
  },

  // 返回 { single: true, src: "..." } 或 { single: false, src1: "...", src2: "..." }
  getIconParts(y, x) {
    const type = this.getIconType(y, x)
    if (!type) {
      // console.log(`无图标类型: (${y},${x})`);
      return {single: true, src: null} // 无图标
    }

    const parts = type.split("-")
    // 判断是否需要拆分：只有当有 3 个 '-'（即 parts.length === 4）时才拆
    if (parts.length === 4) {
      // 按第2个'-'（从0开始是索引2）拆：前2段 + 后2段
      const firstPart = parts[0] + "-" + parts[1] // e.g. "white-box"
      const secondPart = parts[2] + "-" + parts[3] // e.g. "white-target"
      // console.log(`双图标类型: ${firstPart}, ${secondPart}`);
      return {
        single: false,
        src1: this.getIconImagePath(firstPart),
        src2: this.getIconImagePath(secondPart)
      }
    } else {
      // 单图标
      // console.log(`黑角色位置匹配: (${y},${x}),${this.blackY}, ${this.blackX})`);
      console.log(`获取图标类型: (${y},${x}) => ${type}`);
      console.log(`图标路径: ${this.getIconImagePath(type)}`);
      return {
        single: true,
        src: this.getIconImagePath(type)
      }
    }
  },

  getIconImagePath(type) {
    const icons = {
      "white-player": "/common/game/icons/grey-white.png",
      "black-player": "/common/game/icons/white-black.png",
      "white-box": "/common/game/icons/grey-box.png",
      "black-box": "/common/game/icons/white-box.png",
      "white-target": "/common/game/icons/grey-target.png",
      "black-target": "/common/game/icons/white-target.png"
    }
    return icons[type] || ""
  },

  checkWinCondition() {
    // 检查所有白箱子是否在白目标点上
    const whiteWin = this.whiteBoxes.every((box) =>
      this.whiteBoxTargets.some((target) => target.x === box.x && target.y === box.y)
    )

    // 检查所有黑箱子是否在黑目标点上
    const blackWin = this.blackBoxes.every((box) =>
      this.blackBoxTargets.some((target) => target.x === box.x && target.y === box.y)
    )

    // 所有箱子都到位
    if (whiteWin && blackWin && (this.whiteBoxes.length > 0 || this.blackBoxes.length > 0)) {
      prompt.showDialog({
        title: "恭喜通关！",
        message: "你成功将所有箱子推到目标点！",
        buttons: [
          {text: "继续", color: "#667eea"},
          {text: "重玩", color: "#FF416C"}
        ],
        success: (data) => {
          if (data.index === 1) {
            this.initLevel()
          }
        }
      })
    }
  }
}
</script>

<style scoped>
.container {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 8px;
  background-color: #1a1a1a; /* 深蓝灰背景 */
  height: 100%;
  width: 100%;
}

.title {
  background-color: #1a1a1a;
  height: 30px;
  width: 70%;
  object-fit: fill;
  margin: 6px 0 3px 0;
}

.info {
  background-color: #ffffff;
  display: flex;
  justify-content: space-between;
  margin: 2px;
  border-radius: 6px;
  overflow: hidden; /* 隐藏超出边界的图片内容 */
}

.infoText,
.hint {
  height: 40px; /* 统一高度 */
  width: 100%;
  object-fit: fill; /* 保持比例，填充整个区域 */
  border-radius: inherit;
}

.gameArea {
  display: flex;
  flex-direction: column;
  background-color: #1a2530; /* 深灰蓝 */
  padding: 2px;
  margin: 8px 0;
  border-radius: 4px;
}

.cell {
  width: 34px;
  height: 34px;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid #333333;
}

.row {
  display: flex;
}

.switchArea {
  margin-bottom: 10px;
}

.btnRow1,
.btnRow2 {
  display: flex;
  justify-content: center;
}

/* 控制区域 */
.controlArea {
  width: 100%;
  margin-top: 4px;
}

/* 切换按钮 */
.btnSwitch {
  width: 50px; /* 适配手表屏幕 */
  height: 60px;
  border: none;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #ff416c;
  padding: 2px;
  margin: 4px;
  flex-direction: column;
}

/* 方向键容器：调整为居中布局 */
.controlPanel {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: 4px;
}

/* 方向按钮：增加flex布局，确保文字居中 */
.btnArrow {
  width: 30px;
  height: 30px;
  border: none;
  border-radius: 4px;
  margin: 1px;
  display: flex; /* 关键：让文字居中 */
  align-items: center;
  justify-content: center;
}

.btnReset {
  width: 55px;
  height: 40px;
  border: none;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #e74c3c;
  padding: 2px;
  margin: 4px;
  font-size: 12px;
  color: white;
  text-align: center;
}

.resetImage {
  width: 20px;
  height: 20px;
  margin: 2px; /* 根据需要调整 */
  padding: 2px;
}

.combined-icon {
  display: flex;
  align-items: center;
  gap: 1px; /* 小间距 */
}

.icon-row {
  display: flex;
  justify-content: center;
  gap: 2px; /* 图标间距 */
  margin:2px 0;
}

.icon {
  width: 20px;
  height: 20px;
}
</style>
